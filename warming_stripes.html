<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Warming Stripes Visualizer</title>
    <script src="https://cdn.jsdelivr.net/npm/@metapages/metapage@1.8.3/dist/metapage.umd.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #173968 0%, #be2e78 100%);
            min-height: 100vh;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin: 0;
            background: linear-gradient(45deg, #fff, #f0f0f0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .metaframe-info {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .input-status {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 14px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .data-input {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
            align-items: end;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        label {
            font-size: 13px;
            opacity: 0.9;
            font-weight: 600;
        }
        
        select, input, textarea {
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 14px;
        }
        
        textarea {
            resize: vertical;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        button {
            background: linear-gradient(45deg, #be2e78, #173968);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
            font-size: 14px;
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .canvas-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        #stripesCanvas {
            width: 100%;
            height: 250px;
            cursor: crosshair;
            border: 2px solid #eee;
            border-radius: 5px;
            display: block;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin: 15px 0;
            font-size: 14px;
            color: #333;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 25px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }
        
        .legend-value {
            font-weight: 600;
            font-size: 12px;
        }
        
        .info-panel {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 200px;
        }
        
        .dataset-info {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 13px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .error {
            background: rgba(220, 53, 69, 0.3);
            border: 1px solid rgba(220, 53, 69, 0.5);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .success {
            background: rgba(40, 167, 69, 0.3);
            border: 1px solid rgba(40, 167, 69, 0.5);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .data-preview {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            max-height: 150px;
            overflow-y: auto;
        }

        .auto-detect {
            background: rgba(40, 167, 69, 0.2);
            border: 2px solid rgba(40, 167, 69, 0.4);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üå°Ô∏è Interactive Warming Stripes</h1>
            <p>Create beautiful climate visualizations from CSV data with customizable colormaps</p>
        </div>

        <div class="metaframe-info">
            üì° <strong>Metaframe Status:</strong> <span id="metaframeStatus">Initializing...</span><br>
            üîó <strong>Input Source:</strong> <span id="inputSource">Waiting for data from ROHub Loader...</span>
        </div>

        <div id="inputStatus" class="input-status">
            <strong>üì• Input Status:</strong> <span id="inputStatusText">No data received yet. Connect this metaframe to the ROHub Dataset Loader.</span>
        </div>
        
        <div class="data-input">
            <h3>üìä Data Input</h3>
            <div class="control-group">
                <label>CSV Data (from ROHub or manual input):</label>
                <textarea id="csvData" rows="6" placeholder="Data will be automatically loaded from connected ROHub Dataset Loader, or paste your CSV data here...

Example format:
year,temperature,location
1880,13.8,Global
1881,13.9,Global
1882,13.7,Global"></textarea>
            </div>
            
            <div class="controls" style="margin-top: 15px;">
                <div class="control-group">
                    <label>CSV Separator:</label>
                    <select id="separator">
                        <option value="auto">Auto-detect</option>
                        <option value=",">,</option>
                        <option value=";">;</option>
                        <option value="\t">Tab</option>
                        <option value="|">|</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <button onclick="parseCSVData()">üìã Parse CSV</button>
                </div>
                
                <div class="control-group">
                    <button onclick="loadSampleData()">üìä Load Sample Data</button>
                </div>
            </div>
        </div>
        
        <div id="datasetInfo" class="dataset-info" style="display: none;">
            <strong>üìà Parsed Data:</strong> <span id="datasetStats">None</span><br>
            <strong>üìã Available Columns:</strong> <span id="availableColumns">None</span><br>
            <strong>üîó Data Source:</strong> <span id="dataSource">Manual input</span>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>X-Axis (Time/Year):</label>
                <select id="xColumn">
                    <option value="">Select X column...</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Y-Axis (Values):</label>
                <select id="yColumn">
                    <option value="">Select Y column...</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Start Year:</label>
                <input type="number" id="startYear" value="1880" min="1800" max="2030">
            </div>
            
            <div class="control-group">
                <label>End Year:</label>
                <input type="number" id="endYear" value="2023" min="1800" max="2030">
            </div>
            
            <div class="control-group">
                <label>Colormap:</label>
                <select id="colorScale">
                    <option value="classic">Classic (Blue-Red)</option>
                    <option value="viridis">Viridis</option>
                    <option value="plasma">Plasma</option>
                    <option value="coolwarm">Cool-Warm</option>
                    <option value="rdbu">Red-Blue</option>
                    <option value="spectral">Spectral</option>
                    <option value="turbo">Turbo</option>
                    <option value="inferno">Inferno</option>
                    <option value="magma">Magma</option>
                </select>
            </div>
            
            <div class="control-group">
                <button onclick="updateVisualization()">üîÑ Update Stripes</button>
            </div>
            
            <div class="control-group">
                <button onclick="exportImage()">üì∏ Export PNG</button>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="stripesCanvas"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" id="legendLow"></div>
                    <div>
                        <div>Low</div>
                        <div class="legend-value" id="legendLowValue">-</div>
                    </div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" id="legendMid"></div>
                    <div>
                        <div>Average</div>
                        <div class="legend-value" id="legendMidValue">-</div>
                    </div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" id="legendHigh"></div>
                    <div>
                        <div>High</div>
                        <div class="legend-value" id="legendHighValue">-</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="info-panel">
            <div id="statusInfo">Connect to ROHub Dataset Loader or load CSV data to create warming stripes visualization...</div>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>

    <script>
        let metaframe;
        let parsedData = [];
        let canvas, ctx;
        let tooltip;
        let lastInputMetadata = null;
        
        // Enhanced color scales with more options
        const colorScales = {
            classic: {
                colors: [[8, 81, 156], [255, 255, 255], [165, 15, 21]],
                positions: [0, 0.5, 1]
            },
            viridis: {
                colors: [[68, 1, 84], [59, 82, 139], [33, 145, 140], [94, 201, 98], [253, 231, 37]],
                positions: [0, 0.25, 0.5, 0.75, 1]
            },
            plasma: {
                colors: [[13, 8, 135], [84, 2, 163], [139, 10, 165], [185, 50, 137], [219, 92, 104], [244, 136, 73], [254, 188, 43], [240, 249, 33]],
                positions: [0, 0.15, 0.3, 0.45, 0.6, 0.75, 0.9, 1]
            },
            coolwarm: {
                colors: [[59, 76, 192], [144, 178, 254], [221, 220, 219], [245, 156, 125], [180, 4, 38]],
                positions: [0, 0.25, 0.5, 0.75, 1]
            },
            rdbu: {
                colors: [[5, 48, 97], [67, 147, 195], [247, 247, 247], [214, 96, 77], [103, 0, 31]],
                positions: [0, 0.25, 0.5, 0.75, 1]
            },
            spectral: {
                colors: [[158, 1, 66], [213, 62, 79], [244, 109, 67], [253, 174, 97], [254, 224, 139], [255, 255, 191], [230, 245, 152], [171, 221, 164], [102, 194, 165], [50, 136, 189], [94, 79, 162]],
                positions: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]
            },
            turbo: {
                colors: [[48, 18, 59], [80, 2, 148], [182, 54, 121], [251, 135, 97], [254, 206, 84], [239, 254, 240]],
                positions: [0, 0.2, 0.4, 0.6, 0.8, 1]
            },
            inferno: {
                colors: [[0, 0, 4], [31, 12, 72], [85, 15, 109], [136, 34, 106], [186, 54, 85], [227, 89, 51], [249, 140, 10], [249, 201, 50], [252, 255, 164]],
                positions: [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1]
            },
            magma: {
                colors: [[0, 0, 4], [28, 16, 68], [79, 18, 123], [129, 37, 129], [181, 54, 122], [229, 80, 100], [251, 135, 97], [254, 194, 135], [252, 253, 191]],
                positions: [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1]
            }
        };

        window.addEventListener('load', function() {
            canvas = document.getElementById('stripesCanvas');
            ctx = canvas.getContext('2d');
            tooltip = document.getElementById('tooltip');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseleave', hideTooltip);
            
            // Initialize metaframe
            metaframe = new window.Metapage.Metaframe();
            
            metaframe.onState(function(state) {
                console.log('Metaframe state:', state);
                document.getElementById('metaframeStatus').textContent = 'Connected and ready';
            });

            // Handle inputs from ROHub Dataset Loader
            metaframe.onInputs(function(inputs) {
                console.log('Received inputs from ROHub loader:', inputs);
                
                if (inputs.csvData) {
                    // Mark the data input section as auto-detected
                    const dataInput = document.querySelector('.data-input');
                    dataInput.classList.add('auto-detect');
                    
                    // Update input status
                    document.getElementById('inputStatusText').innerHTML = '‚úÖ Data received from ROHub Dataset Loader';
                    document.getElementById('inputSource').textContent = 'ROHub Dataset Loader (auto-connected)';
                    
                    // Load the CSV data
                    document.getElementById('csvData').value = inputs.csvData;
                    
                    // Store metadata if available
                    if (inputs.metadata) {
                        lastInputMetadata = inputs.metadata;
                        document.getElementById('inputSource').textContent = `ROHub: ${inputs.metadata.name}`;
                    }
                    
                    // Auto-parse the data
                    parseCSVData();
                    
                    showStatus('‚úÖ Data automatically loaded from ROHub Dataset Loader!', 'success');
                } else {
                    // Remove auto-detect styling if no data
                    const dataInput = document.querySelector('.data-input');
                    dataInput.classList.remove('auto-detect');
                    
                    document.getElementById('inputStatusText').innerHTML = '‚è≥ Waiting for data from ROHub Dataset Loader...';
                    document.getElementById('inputSource').textContent = 'Waiting for connection...';
                }
            });
        });

        function resizeCanvas() {
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width - 40;
            canvas.height = 250;
            if (parsedData.length > 0) {
                drawWarmingStripes();
            }
        }

        function detectSeparator(csvText) {
            const separators = [',', ';', '\t', '|'];
            const firstLine = csvText.split('\n')[0];
            
            let bestSep = ',';
            let maxCount = 0;
            
            separators.forEach(sep => {
                const count = (firstLine.match(new RegExp(`\\${sep}`, 'g')) || []).length;
                if (count > maxCount) {
                    maxCount = count;
                    bestSep = sep;
                }
            });
            
            return bestSep;
        }

        function parseCSVData() {
            const csvText = document.getElementById('csvData').value.trim();
            const separatorSelect = document.getElementById('separator');
            
            if (!csvText) {
                showStatus('‚ùå Please enter CSV data or connect to ROHub Dataset Loader', 'error');
                return;
            }
            
            try {
                let separator = separatorSelect.value;
                if (separator === 'auto') {
                    separator = detectSeparator(csvText);
                    showStatus(`üîç Auto-detected separator: "${separator}"`, 'success');
                }
                
                if (separator === '\\t') separator = '\t';
                
                const lines = csvText.split('\n').filter(line => line.trim());
                if (lines.length < 2) {
                    throw new Error('CSV must have at least 2 lines (header + data)');
                }
                
                const headers = lines[0].split(separator).map(h => h.trim().replace(/^["']|["']$/g, ''));
                const data = [];
                
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(separator).map(v => v.trim().replace(/^["']|["']$/g, ''));
                    if (values.length === headers.length) {
                        const row = {};
                        headers.forEach((header, index) => {
                            // Try to parse as number
                            const value = values[index];
                            const numValue = parseFloat(value);
                            row[header] = isNaN(numValue) ? value : numValue;
                        });
                        data.push(row);
                    }
                }
                
                parsedData = data;
                updateColumnOptions();
                updateDatasetInfo();
                showStatus(`‚úÖ Parsed ${data.length} rows with ${headers.length} columns`, 'success');
                
            } catch (error) {
                showStatus(`‚ùå CSV parsing error: ${error.message}`, 'error');
            }
        }

        function updateColumnOptions() {
            if (parsedData.length === 0) return;
            
            const columns = Object.keys(parsedData[0]);
            const xSelect = document.getElementById('xColumn');
            const ySelect = document.getElementById('yColumn');
            
            // Clear options
            xSelect.innerHTML = '<option value="">Select X column...</option>';
            ySelect.innerHTML = '<option value="">Select Y column...</option>';
            
            columns.forEach(col => {
                const xOption = document.createElement('option');
                xOption.value = col;
                xOption.textContent = col;
                xSelect.appendChild(xOption);
                
                const yOption = document.createElement('option');
                yOption.value = col;
                yOption.textContent = col;
                ySelect.appendChild(yOption);
            });
            
            // Auto-select reasonable defaults
            const yearCol = columns.find(c => 
                c.toLowerCase().includes('year') || 
                c.toLowerCase().includes('time') ||
                c.toLowerCase().includes('date') ||
                (parsedData[0][c] && String(parsedData[0][c]).match(/\d{4}/))
            );
            
            const valueCol = columns.find(c => 
                c.toLowerCase().includes('temp') || 
                c.toLowerCase().includes('anomal') ||
                c.toLowerCase().includes('avg') ||
                c.toLowerCase().includes('value') ||
                (typeof parsedData[0][c] === 'number' && c !== yearCol)
            );
            
            if (yearCol) {
                xSelect.value = yearCol;
                // Auto-detect year range
                const years = parsedData.map(d => {
                    const val = d[yearCol];
                    if (typeof val === 'number') return val;
                    const match = String(val).match(/(\d{4})/);
                    return match ? parseInt(match[1]) : null;
                }).filter(y => y !== null);
                
                if (years.length > 0) {
                    document.getElementById('startYear').value = Math.min(...years);
                    document.getElementById('endYear').value = Math.max(...years);
                }
            }
            
            if (valueCol) {
                ySelect.value = valueCol;
            }
            
            // If we have good defaults, auto-update the visualization
            if (yearCol && valueCol) {
                setTimeout(() => {
                    updateVisualization();
                }, 500);
            }
        }

        function updateDatasetInfo() {
            const datasetInfo = document.getElementById('datasetInfo');
            const datasetStats = document.getElementById('datasetStats');
            const availableColumns = document.getElementById('availableColumns');
            const dataSource = document.getElementById('dataSource');
            
            if (parsedData.length > 0) {
                const columns = Object.keys(parsedData[0]);
                
                datasetStats.textContent = `${parsedData.length} rows, ${columns.length} columns`;
                availableColumns.textContent = columns.join(', ');
                
                if (lastInputMetadata) {
                    dataSource.innerHTML = `ROHub: <a href="${lastInputMetadata.url}" target="_blank">${lastInputMetadata.name}</a>`;
                } else {
                    dataSource.textContent = 'Manual input';
                }
                
                datasetInfo.style.display = 'block';
            }
        }

        function loadSampleData() {
            const sampleCSV = `year,temperature,anomaly,region
1880,13.8,-0.2,Global
1881,13.9,-0.1,Global
1882,13.7,-0.3,Global
1883,13.6,-0.4,Global
1884,13.4,-0.6,Global
1885,13.5,-0.5,Global
1890,13.3,-0.7,Global
1900,13.9,-0.1,Global
1910,13.6,-0.4,Global
1920,13.8,-0.2,Global
1930,14.0,0.0,Global
1940,14.1,0.1,Global
1950,13.9,-0.1,Global
1960,14.0,0.0,Global
1970,14.1,0.1,Global
1980,14.3,0.3,Global
1990,14.4,0.4,Global
2000,14.6,0.6,Global
2010,14.7,0.7,Global
2020,15.0,1.0,Global
2023,15.1,1.1,Global`;
            
            document.getElementById('csvData').value = sampleCSV;
            lastInputMetadata = null; // Clear metadata for sample data
            
            // Remove auto-detect styling
            const dataInput = document.querySelector('.data-input');
            dataInput.classList.remove('auto-detect');
            
            parseCSVData();
        }

        function getColorFromScale(value, scaleName) {
            const scale = colorScales[scaleName];
            const colors = scale.colors;
            const positions = scale.positions;
            
            // Clamp value between 0 and 1
            value = Math.max(0, Math.min(1, value));
            
            // Find the two colors to interpolate between
            let i = 0;
            while (i < positions.length - 1 && value > positions[i + 1]) {
                i++;
            }
            
            if (i === positions.length - 1) {
                return colors[i];
            }
            
            // Interpolate between colors[i] and colors[i+1]
            const t = (value - positions[i]) / (positions[i + 1] - positions[i]);
            const color1 = colors[i];
            const color2 = colors[i + 1];
            
            return [
                Math.round(color1[0] + (color2[0] - color1[0]) * t),
                Math.round(color1[1] + (color2[1] - color1[1]) * t),
                Math.round(color1[2] + (color2[2] - color1[2]) * t)
            ];
        }

        function updateLegend(scaleName, minVal, maxVal, avgVal) {
            const legendLow = document.getElementById('legendLow');
            const legendMid = document.getElementById('legendMid');
            const legendHigh = document.getElementById('legendHigh');
            const legendLowValue = document.getElementById('legendLowValue');
            const legendMidValue = document.getElementById('legendMidValue');
            const legendHighValue = document.getElementById('legendHighValue');
            
            const lowColor = getColorFromScale(0, scaleName);
            const midColor = getColorFromScale(0.5, scaleName);
            const highColor = getColorFromScale(1, scaleName);
            
            legendLow.style.background = `rgb(${lowColor.join(',')})`;
            legendMid.style.background = `rgb(${midColor.join(',')})`;
            legendHigh.style.background = `rgb(${highColor.join(',')})`;
            
            legendLowValue.textContent = minVal.toFixed(2);
            legendMidValue.textContent = avgVal.toFixed(2);
            legendHighValue.textContent = maxVal.toFixed(2);
        }

        function updateVisualization() {
            drawWarmingStripes();
        }

        function drawWarmingStripes() {
            const xColumn = document.getElementById('xColumn').value;
            const yColumn = document.getElementById('yColumn').value;
            const startYear = parseInt(document.getElementById('startYear').value);
            const endYear = parseInt(document.getElementById('endYear').value);
            const colorScale = document.getElementById('colorScale').value;
            const statusInfo = document.getElementById('statusInfo');
            
            if (parsedData.length === 0) {
                statusInfo.innerHTML = '‚ùå No data loaded. Please connect to ROHub Dataset Loader or paste CSV data.';
                return;
            }
            
            if (!xColumn || !yColumn) {
                statusInfo.innerHTML = '‚ùå Please select both X and Y columns to create warming stripes.';
                return;
            }
            
            // Filter and sort data
            let filteredData = parsedData.filter(d => {
                const xVal = d[xColumn];
                const yVal = d[yColumn];
                
                if (typeof yVal !== 'number' || isNaN(yVal)) return false;
                
                if (xColumn.toLowerCase().includes('year') || typeof xVal === 'string') {
                    const year = typeof xVal === 'number' ? xVal : parseInt(String(xVal).match(/(\d{4})/)?.[1] || xVal);
                    return year >= startYear && year <= endYear && !isNaN(year);
                }
                return true;
            });
            
            // Sort by X column
            filteredData.sort((a, b) => {
                let aVal = a[xColumn];
                let bVal = b[xColumn];
                
                if (typeof aVal === 'string' && aVal.match(/\d{4}/)) {
                    aVal = parseInt(aVal.match(/(\d{4})/)[1]);
                }
                if (typeof bVal === 'string' && bVal.match(/\d{4}/)) {
                    bVal = parseInt(bVal.match(/(\d{4})/)[1]);
                }
                
                return aVal - bVal;
            });
            
            if (filteredData.length === 0) {
                statusInfo.innerHTML = '‚ùå No data in selected range.';
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Get Y values for normalization
            const yValues = filteredData.map(d => d[yColumn]);
            const minVal = Math.min(...yValues);
            const maxVal = Math.max(...yValues);
            const avgVal = yValues.reduce((a, b) => a + b, 0) / yValues.length;
            
            // Update legend
            updateLegend(colorScale, minVal, maxVal, avgVal);
            
            // Draw stripes
            const stripeWidth = canvas.width / filteredData.length;
            
            filteredData.forEach((dataPoint, index) => {
                const yVal = dataPoint[yColumn];
                
                // Normalize to 0-1 range
                const normalized = (yVal - minVal) / (maxVal - minVal);
                
                const color = getColorFromScale(normalized, colorScale);
                ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                ctx.fillRect(index * stripeWidth, 0, stripeWidth, canvas.height);
            });
            
            // Update info
            let sourceInfo = '';
            if (lastInputMetadata) {
                sourceInfo = `<br>üîó <strong>Source:</strong> <a href="${lastInputMetadata.url}" target="_blank" style="color: #fff;">${lastInputMetadata.name}</a>`;
            }
            
            statusInfo.innerHTML = `
                ‚úÖ <strong>Visualization:</strong> ${filteredData.length} data points<br>
                üìà <strong>X-Axis:</strong> ${xColumn}<br>
                üìä <strong>Y-Axis:</strong> ${yColumn} (${minVal.toFixed(2)} to ${maxVal.toFixed(2)})<br>
                üé® <strong>Colormap:</strong> ${colorScale}<br>
                üìÖ <strong>Range:</strong> ${startYear} - ${endYear}${sourceInfo}
            `;
        }

        function handleMouseMove(event) {
            const xColumn = document.getElementById('xColumn').value;
            const yColumn = document.getElementById('yColumn').value;
            
            if (!xColumn || !yColumn || parsedData.length === 0) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            
            const startYear = parseInt(document.getElementById('startYear').value);
            const endYear = parseInt(document.getElementById('endYear').value);
            
            let filteredData = parsedData.filter(d => {
                const xVal = d[xColumn];
                const yVal = d[yColumn];
                
                if (typeof yVal !== 'number' || isNaN(yVal)) return false;
                
                if (xColumn.toLowerCase().includes('year') || typeof xVal === 'string') {
                    const year = typeof xVal === 'number' ? xVal : parseInt(String(xVal).match(/(\d{4})/)?.[1] || xVal);
                    return year >= startYear && year <= endYear && !isNaN(year);
                }
                return true;
            });
            
            const stripeWidth = canvas.width / filteredData.length;
            const index = Math.floor(x / stripeWidth);
            
            if (index >= 0 && index < filteredData.length) {
                const dataPoint = filteredData[index];
                showTooltip(event.clientX, event.clientY, dataPoint, xColumn, yColumn);
            }
        }

        function showTooltip(x, y, dataPoint, xCol, yCol) {
            const allColumns = Object.keys(dataPoint);
            let tooltipContent = `<strong>${xCol}:</strong> ${dataPoint[xCol]}<br>`;
            tooltipContent += `<strong>${yCol}:</strong> ${dataPoint[yCol]}<br>`;
            
            // Show other relevant columns
            allColumns.forEach(col => {
                if (col !== xCol && col !== yCol && dataPoint[col] !== undefined) {
                    tooltipContent += `<strong>${col}:</strong> ${dataPoint[col]}<br>`;
                }
            });
            
            tooltip.innerHTML = tooltipContent;
            tooltip.style.left = Math.min(x + 10, window.innerWidth - 220) + 'px';
            tooltip.style.top = y - 10 + 'px';
            tooltip.style.opacity = '1';
        }

        function hideTooltip() {
            tooltip.style.opacity = '0';
        }

        function exportImage() {
            const link = document.createElement('a');
            link.download = 'warming-stripes.png';
            link.href = canvas.toDataURL();
            link.click();
            
            showStatus('‚úÖ Image exported successfully!', 'success');
        }

        function showStatus(message, type) {
            const statusInfo = document.getElementById('statusInfo');
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : '';
            
            if (className) {
                const div = document.createElement('div');
                div.className = className;
                div.innerHTML = message;
                document.querySelector('.info-panel').appendChild(div);
                
                setTimeout(() => {
                    if (div.parentNode) {
                        div.parentNode.removeChild(div);
                    }
                }, 3000);
            } else {
                statusInfo.innerHTML = message;
            }
        }
